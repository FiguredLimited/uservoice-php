<?php
namespace UserVoice;

##
# Generates a Single-Sign-On (SSO) token which you can add to a uservoice URL:
# http://uservoice-subdomain.uservoice.com?sso=HERE
#
# If you experience difficulties with the SSO tokens generated by the function 
# below, you might have configured mbstring.func_overload other than 0. If so,
# wrap the call to generate_sso_token like this:
#
#    $original_encoding = mb_internal_encoding();
#    mb_internal_encodig('ASCII');
#
#    $sso_token = \UserVoice\generate_sso_token(...)
#
#    mb_internal_encoding($original_encoding);
#
#    // Now use the $sso_token
#

function generate_sso_token($subdomain_key, $sso_key, $user_hash, $valid_for = 300) {


    $salted = $sso_key . $subdomain_key;
    $hash = hash('sha1',$salted,true);
    $saltedHash = substr($hash,0,16);
    $iv = "OpenSSL for Ruby";

    if (!array_key_exists('expires', $user_hash)) {
        $user_hash['expires'] = gmdate('Y-m-d H:i:s', time()+$valid_for);
    }

    $data = json_encode($user_hash);


    for ($i = 0; $i < 16; $i++) {
        $data[$i] = $data[$i] ^ $iv[$i];
    }

    $pad = 16 - (strlen($data) % 16);
    $data = $data . str_repeat(chr($pad), $pad);

    $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128,'','cbc','');
    mcrypt_generic_init($cipher, $saltedHash, $iv);
    $encryptedData = mcrypt_generic($cipher,$data);
    mcrypt_generic_deinit($cipher);

    $encryptedData = base64_encode($encryptedData);

    return urlencode($encryptedData);
}

?>
